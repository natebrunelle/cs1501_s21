---
title: Unit 3 Exercises, Dynamic Programming
...

All Dynamic Programming exercises will be posted here as they are released (about 1 week before the deadline).

# Instructions

Exercises are due some Monday and Fridays. I recommend you start them early. In my experience with solving tricky problems, it is more productive to work on them in short bursts, with breaks in between. To solve a hard problem, it's less about the number of hours you spend working on it than it is about the number of showers.

# Policies

You may collaborate with up to 4 other people (i.e. a group of up to 5 total) when completing exercises. You may additionally use external materials with following restrictions:

- Your write-ups must be done entirely independently. You may discuss with collaborators, but we expect that the answers you submit be expressed in your own words. 
- You must understand everything you submit. Do not submit anything you could not explain to a member of the course staff.
- You **must** cite any and every source you consult beyond officially-provided materials. Included in your citation, you must identify which components of your submission came from each source (it will be understood that content with no citation is your own exclusive work). Your collaborators are considered to be sources, and so should be cited. An example citation might look like: "I collaborated with David Evans on the pdf style, I consulted \url{https://www.overleaf.com/learn/latex/Aligning\%20equations\%20with\%20amsmath} for help with the align environment, Robbie Hott helped me to debug the for loop on line 107 of my code."
- Do not seek "hints" or entire solutions to the problems. Limit your searching to background information only. Do not use Chegg.

# Deliverables

Unless otherwise indicated, each problem set will be submitted as either a pdf or a java/python file on the [Assignments page](https://www.kytos.cs.virginia.edu/cs4102). Unless otherwise indicated, pdfs must be generated by LaTeX, and must be done by modifying the template file given.

# Problem Sets


There will be a total of 2 exercises for this unit (one programming, one written). The average across these exercsises will count as 50% of your grade on unit 2. The remaining 50% will be your grade on this unit's quiz.

## Exercise 1: Drainage

This first exercise will be a programming assignment. In our experience, implementing an "easy" dynamic programming solution helps students to understand how they work and why they're valuable, which will improve their ability to develop more complicated dynamic programming algorithms for future written assignments.

You may use either Python3 or Java for your implementation. If you have not yet set up your programming environment, there are instructions on how to do so with [Exercise 0](http://www.cs.virginia.edu/~njb2b/cs4102/f20/getting_started.html).

To complete this assignment:

1. Read the [description of the drainage problem](files/exercises/dp1.pdf).

1. Download the zip file for your desired programming language: [Java](files/exercises/drainage_java.zip) or [Python](files/exercises/drainage_python.zip)

    - **For Java**: You will see two `.java` files: `Drainage.java` which is where you will implement your dynamic programming algorithm, and `DrainageTester.java` which will run your algorithm on several test cases.
    - **For Python3**: You will see two `.py` files: `drainage.py` which is where you will implement your dynamic programming algorithm, and `drainage_tester.py` which will run your algorithm on several test cases.

1. Implement the functions/methods called `find_drain` and `backtrack` contained in either `Drainage.java` or `drainage.py`. This implementation must be dynamic programming. To help you out, we have already implemented or provided signatures for some functions/methods (more detailed descriptions appear within the code):
    - `backtrack`: Reconstructs a path after the longest has been found, you must implement this.
    - `find_drain`: Finds the longest river that ends at the given location, you must implement this.
    - `longest_drain`: Finds the longest river overall. Do not modify this function.
    - Feel free to add any additional functions/methods that you wish.

1. Check your implementation by running either `DrainageTester.java` or `drainage_pair_tester.py` (we will use exactly these to grade your code, so if you modify them, I recommend checking against the original versions before submitting). It will read input files and run each of the provided tests against your implementation of the drainage problem at least once. All test cases will first be run with backtracking disabled, but timing enabled. After this, the smallest tests (all bu `long.txt` and `big.txt`) will be run with backtracking enabled. We provide a description of each test case and the return value of a correct implementation (note that longest paths are not necessarily unique).
    - `sample.txt`: This is the test case provided in the problem description. The longest river has length 7, an example longest path is "99, 96, 58, 29, 24, 8, 3".
    - `small.txt`: This is a 10x10 grid of random values. The longest river has length 6, an example longest path is "983, 946, 939, 937, 936, 930".
    - `medium.txt`: This is a 50x50 grid of random values. The longest river has length 10, an example longest path is "1313, 1301, 1176, 1168, 1140, 1107, 1097, 1039, 947, 926".
    - `flat.txt`: This is a 100x100 grid containing only duplicates of the same value. The longest river has length 1, an example longest path is "910".
    - `long.txt`: This is a 31x31 grid containing values such that the longest river navigates the entire grid. The longest river has length 961, we will not include an exmaple longest path for obvious reasons.
    - `big.txt`: This is a 2000x2000 grid of random values. The longest river has length 16. We do not provide an example longest path because the grid is too large for it to be worthwhile for verification anyway.
    
1. Once you're satisfied with your implementation, check for any lingering print statements you might have added, then submit your `Drainage.java` or `drainage.py` file to the submission system.



## Exercise 2

This second exercise is intended to challenge you in order to hone your skill in developing and analyzing dynamic programming algorithms.

For your convenience, here is a pdf of the problem set: [dp2_blank.pdf](files/exercises/dp2_blank.pdf).

To complete this assignment:

- First download this zip file - [dp2.zip](files/exercises/dp2.zip) - and upload as a new project in Overleaf.

- Next, add you name and computing id under `submitter` in *exercise.tex*.

- Once you've solved a problem, edit the corresponding *problemX.tex* file to include your answers to the problems. In general, everything you need to change within the problem set is marked with a `TODO` comment, so look for those.

- After including all solutions, comment out the line that reads `usepackage{algo}` and uncomment the line that reads `usepackage[response]{algo}`. This will remove the problem set instructions, leaving your solutions in the document.

- Remember to add your resources and collaborators to `collaborators` in *exercise.tex*

- Finally, download the pdf generated by your LaTeX code, call it *dp2.pdf*, and submit it on the [assignments page](https://www.kytos.cs.virginia.edu/cs4102).






