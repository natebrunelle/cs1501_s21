---
title: Unit 1 Exercises: Divide and Conquer
...

All Divide and Conquer exercises will be posted here as they are released (at least 1 week before the deadline).

# Instructions

Exercises are due some Tuesdays and Fridays. I recommend you start them early. In my experience with solving tricky problems, it is more productive to work on them in short bursts, with breaks in between. To solve a hard problem, it's less about the number of hours you spend working on it than it is about the number of showers.

# Policies

You may collaborate with up to 4 other people (i.e. a group of up to 5 total) when completing exercises. You may additionally use external materials with following restrictions:

- Your write-ups must be done entirely independently. You may discuss with collaborators, but we expect that the answers you submit be expressed in your own words. 
- You must understand everything you submit. Do not submit anything you could not explain to a member of the course staff.
- You **must** cite any and every source you consult beyond officially-provided materials. Included in your citation, you must identify which components of your submission came from each source (it will be understood that content with no citation is your own exclusive work). Your collaborators are considered to be sources, and so should be cited. An example citation might look like: "I collaborated with David Evans on the pdf style, I consulted \url{https://www.overleaf.com/learn/latex/Aligning\%20equations\%20with\%20amsmath} for help with the align environment, Robbie Hott helped me to debug the for loop on line 107 of my code."
- Do not seek "hints" or entire solutions to the problems. Limit your searching to background information only. Do not use Chegg.

# Deliverables

Unless otherwise indicated, each problem set will be submitted as either a pdf or a java/python file on the [Assignments page](https://www.kytos.cs.virginia.edu/cs4102). Unless otherwise indicated, pdfs must be generated by LaTeX, and must be done by modifying the template file given.

# Problem Sets


This is the first unit that will count for a grade. There will be a total of 3 exercises for this unit (two written and one programming). The average across these 3 will count as 50% of your grade on unit 1. The remaining 50% will be your grade on this unit's quiz.

## Exercise 1

This first exercise is intended to help you develop familiarity with asymptotic complexity, recurrence relations, and divide and conquer algorithms. In total there are 3 problems, one for each of those respective concepts.

For your convenience, here is a pdf of the problem set: [dandc1_blank.pdf](files/exercises/dandc1_blank.pdf).

To complete this assignment:

- First download this zip file - [dandc1.zip](files/exercises/dandc1.zip) - and upload as a new project in Overleaf.

- Next, add you name and computing id under `submitter` in *exercise.tex*.

- Once you've solved a problem, edit the corresponding *problemX.tex* file to include your answers to the problems. In general, everything you need to change within the problem set is marked with a `TODO` comment, so look for those.

- After including all solutions, comment out the line that reads `usepackage{algo}` and uncomment the line that reads `usepackage[response]{algo}`. This will remove the problem set instructions, leaving your solutions in the document.

- Remember to add your resources and collaborators to `collaborators` in *exercise.tex*

- Finally, download the pdf generated by your LaTeX code, call it *dandc1.pdf*, and submit it on the [assignments page](https://www.kytos.cs.virginia.edu/cs4102).

## Exercise 2

This second exercise is intended to challenge you in order to hone your skill in developing divide and conquer algorithms, and to give you experience with solving recurrence relations.

For your convenience, here is a pdf of the problem set: [dandc2_blank.pdf](files/exercises/dandc2_blank.pdf).

To complete this assignment:

- First download this zip file - [dandc2.zip](files/exercises/dandc2.zip) - and upload as a new project in Overleaf.

- Next, add you name and computing id under `submitter` in *exercise.tex*.

- Once you've solved a problem, edit the corresponding *problemX.tex* file to include your answers to the problems. In general, everything you need to change within the problem set is marked with a `TODO` comment, so look for those.

- After including all solutions, comment out the line that reads `usepackage{algo}` and uncomment the line that reads `usepackage[response]{algo}`. This will remove the problem set instructions, leaving your solutions in the document.

- Remember to add your resources and collaborators to `collaborators` in *exercise.tex*

- Finally, download the pdf generated by your LaTeX code, call it *dandc1.pdf*, and submit it on the [assignments page](https://www.kytos.cs.virginia.edu/cs4102).

## Programming Exercise

This is the last exercise for the Divide and Conquer unit. It is intended to exercise your ability to implement the algorithms we've been discussing in lecture, and show that theoretical running times benefits demonstrated in class result in actually faster algorithms.

The short description of this assignment is that you'll be implementing the closest pair of points problem discussed in class on September 10. You may use either Python or Java for your implementation. If you have not yet set up your programming environment, there are instructions on how to do so with [Exercise 0](http://www.cs.virginia.edu/~njb2b/cs4102/f20/getting_started.html).

To complete this assignment:

1. First download the zip file for your desired programming language: [Java](files/exercises/closestpair_java.zip) or [Python](files/exercises/closestpair_python.zip)

    - **For Java**: You will see four `.java` files: `Point.java` which implements a class for representing cartesian points, `Pair.java` which allows for us to return two values from a function, `ClosestPair.java` where you will implement the closest pair of points algorithm, and `ClosestPairTester.java` which will run several tests to compare the behavior of your algorithm with a quadratic implementation of closest pair of points. You will additionally see several `.txt` files which contain the test cases. You will only be submitting `ClosestPair.java`, so do not modify any other files.
    - **For Python**: You will see two `.py` files: `closest_pair.py` where you will implement the closest pair of points algorithm, and `closest_pair_tester.py` which will run several tests to compare the behavior of your algorithm with a quadratic implementation of closest pair of points. You will additionally see several `.txt` files which contain the test cases. You will only be submitting `closest_pair.py`, so do not modify any other files.
    
1. Implement the function/method called `dc_closest` contained in either `ClosestPair.java` or `closest_pair.py`. This implementation must be divide and conquer and you must clearly label the base case(s), divide step, conquer step, and combine step (some guidance is provided in the comments). To help you out, we have already implemented or provided signatures for some functions/methods:
    - `distance`: calculates the Euclidean distance between a pair of points. Do not modify this.
    - `quadratic_closest`: Finds the closest pair of points using a quadratic procedure. This is used for timing comparisons (to ensure that your solution is asymptotically faster), correctness verification (make sure your implementation's answers match), and can also be used for your base case(s). It returns both the distance between then closest pair of points as well as the points sorted by y coordinate (for use as a base case). Do not modify this.
    - `get_runway`: This is not implemented, but you may find it helpful to do so for your combine step. The idea is that this would take your set of points, where the input was divided, and the value of delta, and return all points in the runway. You may modify this, but are not required to do so.
    - `merge`: This is not implemented, but you may find it helpful to do so for your combine step. The idea is that this would take two lists of points sorted by y coordinate and merge them together by y coordinate. You may modify this, but are not required to do so.
    - `dc_closest`: Your primary task for this assignment is to implement this function. It should take a list of points as input, and as output return the closest pair of points as well as the points re-ordered by y coordinate. You must modify this.
    - `closest_pair`: This is just a helper function to make the call to `dc_closest` look nicer by hiding its second return value, and doing the sort-by-x step for you. Do not modify this.
    - `main`: gives a simple example invocation of your algorithm. You may modify this.
    - Feel free to add any additional functions/methods that you wish.

1. Check your implementation by running either `ClosestPairTester.java` or `closest_pair_tester.py`. It will run each of the provided tests against your implementation of closest pair of points as well as the quadratic implementation. Verify that both implementations give the same distance as the answer, and that your implementation's running time grows substantially more slowly thant the quadratic as the input size increases. For us, when running the `big.txt` test case, our divide and conquer implementation was 10x faster than the quadratic. 

1. Once you're satisfied with your implementation, submit your `ClosestPair.java` or `closest_pair.py` file to the submission system.
